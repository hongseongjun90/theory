# 객체지향언어

## 객체지향언어

### 주요특징

1. 코드의 재 사용성이 높다.
2. 코드 관리가 용이하다.
3. 신뢰성이 높은 프로그래밍을 가능하게 한다.

즉, 코드의 재사용성이 높고 유지보수가 용이하다.

# 클래스와 객체

## 클래스와 객체의 정의와 용도

클래스의 정의 "객체를 정의해 놓은 것"
클래스의 용도 "객체를 생성하는데 사용"

객체의 정의 "실제로 존재하는 것. 사물, 개념"
객체의 용도 " 객체가 가지고 있는 기능과 속성에 따라 다름"

유형의 객체 "책상, 의자, 자동차와 같은 사물"
무형의 객체 " 수학공식, 프로그램 에러와 같은 논리나 개념"

## 객체와 인스턴스

클래스로부터 객체를 만드는 과정을 클래스의 "인스턴스화" 라고한다. 
어떤 클래스로부터 만들어진 객체를 클래스의 "인스턴스" 라고 한다.

클래스 -> "인스턴스화" -> 인스턴스(객체)

## 객체의 구성요소 속성과 기능

객체는 속성과 기능, 두 종류의 구성요소로 이루어져있다.
일반적으로 객체는 다수의 속성과 다수의 기능을 갖는다.
즉, 객체는 속성과 기능의 집합.
그리고 그 객체가 갖고 있는 속성과 기능을 그 객체의 멤버(구성원; member)라고 한다.

클래스란 객체를 정의한 것이므로 클래스에는 객체의 모든 속성과 기능이 정의되어 있다.
클래스로부터 객체를 생성하면 클래스에 정의된 속성과 기능을 가진 객체가 만들어진다.

속성(property) 멤버변수, 특성, 필드, 상태
기능(function) 메서드, 함수, 행위

예) TV 
TV의 속성 크기, 길이, 색상, 볼륨, 채널
TV의 기능 켜기, 끄기, 볼륨 높이기, 볼륨 낮추기, 채널 변경 등..

객체지향 프로그래밍에서는 속성과 기능을 각 변수와 메서드로 표현한다.

속성 -> 멤버변수
기능 -> 메서드

채널 -> int channel
채널 높이기 -> channelUP() {...}

위의 내용으로 TV 클래스를 만들어보면 다음과 같다.

class TV {
  String color; // 색깔
  boolean power; // 전원상태
  int channel; // 채널
  
  void power() {power = !power;}
  void channelUp() {channel++;}
  void channelDown() {channel--;}
  }
  
## 인스턴스 생성과 사용

클래스명 변수명; // 클래스의 객체를 참조하기 위한 참조변수를 선언
변수명 = new 클래스명(); // 클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장

Tv t; // Tv클래스 타입의 참조변수 t를 선언
t = new Tv(); // Tv인스턴스 생성한 후, 생성된 Tv인스턴스의 주소를 t에 저장

1. Tv t; 
Tv 클래스 타입의 참조변수 t를 선언한다. 메모리에 참조변수 t를 위한 공간이 마련된다. 아직 인스턴스가 생성되지 않았으므로 참조변수는 아무것도 할 수 없다.

2. Tv t = new Tv();
연산자 new에 의해 Tv클래스이 인스턴스가 메모리의 빈 공간에 생성된다. 이때 멤버변수는 각 자료형에 해당하는 기본 값으로 초기화 된다.
이제는 참조변수 t를 통해 Tv인스턴스에 접근할 수 있다. 인스턴스를 다루기 위해서는 참조변수가 반드시 필요하다.

3. t.channel = 7;
참조변수 t에 저장된 주소에 있는 인스턴스 멤버변수 chnnel에 7을 저장한다. 여기서 알 수 있는 것처럼 인스턴스 멤버변수(속성)을 사용하려면 "참조변수.멤버변수"와 같이 하면된다.

4. t.channelDown();
참조변수 t가 참조하고 있는 Tv인스턴스의 channelDown메서드를 호출한다. channelDown메서드는 멤버변수 channel에 저장되어 있는 값을 1 감소시킨다.

5. sysout.prinln("현재 채널은 " + t.channel + "입니다");
참조변수 t가 참조하고 있는 Tv 인스턴스의 멤버변수 channel에 저장되어 있는 값을 출력한다.

그외)

Tv t1 = new Tv();
Tv t2 = new Tv();

t1.channel = 1;

이 경우 t1이 가리키는 인스턴스의 멤버변수 channel의 값을 7로 변경.
        t2의 경우에는 값이 지정되어있지 않기 때문에 기본 값인 0.
        
Tv t1 = new Tv();
Tv t2 = new Tv();

t2 = t1; 
t1이 저장하고 있는 값(주소)을 t2에 저장한다.
이 문장이 수행되면 t2가 가지고 있던 값은 잃어버리고 t1에 저장되어 있던 값이 t2에 저장된다.

t1.chnnel = 1;

sysout.println("t1의 channel 값은" + t1.channel + "입니다");
sysout.println("t2의 channel 값은" + t2.channel + "입니다");

// 결과는 같다. 둘다 1.

## 객체 배열

많은 수의 객체를 다룰때 배열로 다루면 편리하다.
이 때 객체 배열안에 객체가 저장되는 것이 아닌 주소가 저장된다.

Tv tv1, tv2, tv3; -> Tv[] tvArr = new Tv[3];

길이가 3인 객체 배열 tvArr을 생성하면, 각 요소는 참조변수의 기본 값인 null로 자동 초기화 되며, 이 객체 배열은 3개의 객체주소를 저장할 수 있다.

Tv[] tvArr = new Tv[3]; // 참조변수 배열(객체배열)을 생성

// 객체를 생성해서 배열의 각 요소에 저장

tvArr[0] = new Tv();
tvArr[1] = new Tv();
tvArr[2] = new Tv();
 
배열의 초기화 블럭을 사용하면 다음과 같이 한 줄로 간단히 할 수 있다.

Tv[] tvArr = {new Tv(), new Tv(), new Tv()};

다뤄야 할 객체의 수가 많을때는 for문 사용하면 된다.

Tv[] tvArr = new Tv[100];

for (int i = 0; i < tvArr.length; i++) {
  tvArr[i] = new tv();
  }
  
## 클래스의 또 다른 정의

### 클래스 데이터와 함수의 결합

1. 변수 
하나의 데이터를 저장할 수 있는 공간

2. 배열 
같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간

3. 구조체 
서로 관련된 여러 데이터를 종류에 관계 없이 하나의 집합으로 저장할 수 있는 공간

4. 클래스 
데이터와 함수의 결합(구조체+함수)

### 클래스 사용자정의 타입

프로그래머가 서로 관련된 변수들을 묶어서 하나의 타입으로 새로 추가하는 것을 사용자정의 타입 이라고 한다.
객체지향언어에서는 클래스가 곧 사용자 정의 타입이다.

예) 
class Time {
  int hour;
  int minute;
  float secount;
  }
  
위의 코드는 시, 분, 초를 저장하기 위한 세 변수를 멤버변수로 갖는 Time클래스를 정의한 것이다.

# 변수와 메서드

## 선언위치에 따른 변수의 종류

클래스변수, 인스턴스변수, 지역변수 모두 세 종류가 있다.
변수의 종류를 결정짓는 중요한 요소는 "변수의 선언된 위치"
멤버변수를 제외한 나머지 변수들은 모두 지역변수이며, 멤버변수 중 static이 붙은 것은 클래스변수, 붙지 않은 것은 인스턴스변수 이다.

class Variables { - 메서드영역을 제외한 나머지 클래스영역
  int iv;        // 인스턴스 변수
  static int cv; // 클래스 변수(static 변수, 공유 변수)
  
  void method() { - 메서드영역
    int lv = 0;  // 지역변수
  }
} 

1. 인스턴스변수

클래스영역에 선언되며, 클래스의 인스턴스를 생성할 때 만들어진다.
인스턴스 변수의 값을 읽어 오거나 저장하기 위해서는 먼저 인스턴스를 생성해야 한다.
인스턴스는 독립적인 저장공간을 가지므로 서로 다른 값을 가질 수 없다.
인스턴스마다 고유한 상태를 유지해야 하는 속성의 경우 인스턴스 변수로 선언한다.

2. 클래스변수 = 스태틱변수

스태틱변수는 모든 인스턴스가 공통된 저장공간(변수)을 공유하게 된다.
한 클래스의 모든 인스턴스들이 공통적인 값을 유지해야 하는 속성의 경우 스태틱 변수로 선언해야 한다.
스태틱 변수는 인스턴스 변수와 달리 인스턴스를 생성하지 않고도 언제라도 바로 사용할 수 있는 특징이 있으며,
"클래스이름.클래스변수" 와 같은 형식으로 사용한다.
public을 앞에 붙이면 같은 프로그램 내에서 어디서나 접근할 수있는 "전역변수" 성격을 가지게 된다.

3. 지역변수

메서드 내에 선언되어 메서드 내에서만 사용가능하다.
메서드가 종료되면 소멸되어 사용할 수없다.
for문 또는 while문의 블럭내에 선언된 지역변수는, 지역변수가 선언된 블럭{} 내에서만 사용가능하며, 
블럭{]을 벗어나면 소멸되어 사용할 수 없게 된다.

// 인스턴스 변수는 인스턴스가 생성될 때마다 생성되므로 인스턴스마다 각기 다른 값을 유지할 수 있지만,
클래스변수는 모든 인스턴스가 하나의 저장공간을 유지하므로 항상 공통된 값을 가지게 된다.

## 메서드

메서드는 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것이다.
메서드가 작업을 수행하는데 필요 값을 넣고 원하는 결과를 얻으면 된다. 내부적으로 어떤 과정을 거쳐 결과를 만드는지 몰라도 된다.
즉, 입력값과 출력값만 알면 된다.

### 메서드를 사용하는 이유

1. 높은 재 사용성
2. 중복된 코드 제거
3. 프로그램의 구조화

## 메서드의 선언과 구현

반환타입 메서드이름 (타입변수명, 타입변수명.. ) { // 선언부
  메서드 호출 시 수행될 코드                      // 구현부
  }
  
int(반환타입) add(메서드이름) (int a(타입변수명), int b) {
  int result = a + b;
  return result;
  }

### 메서드 선언부

"매서드 이름"과 "매개변수 선언" "반환타입"으로 구성되어 있다.
예를 들어 아래 정의된 메서드 add는 두 개의 정수를 입력 받아 두 값의 더한 값을 반환한다.

int             add         (int x, int y) {
반환타입(출력)  메서드이름  매개변수 선언(입력)
  int result = x + y;
  return result; 
         결과반환
  } 
  
### 매개변수 선언 (지역변수)

매개변수는 메서드가 작업을 수행하는데 필요한 값을 (입력) 제공받기 위한 것이며 
필요한 값의 개수만큼 변수를 선언하며 각 변수간의 구분은 쉼표를 사용한다.

### 메서드의 이름

특정 작업을 수행함으로 메서드의 이름은 "add"처럼 동사인 경우가 많다.

### 반환 타입

메서드의 작업수행 결과(출력) 인 반환값의 타입을 적는다. 반환값이 없는 경우 "void"를 적어야 한다.

### 메서드의 구현부

{} 괄호를 "메서드의 구현부" 라고 한다.

### return 문

메서드의 반환 타입이 void가 아닌 경우 구현부{} 안에 반드시 "return" 반환값이 반드시 포함되어야 한다.
이 문장은 작업을 수행한 결과인 반환값을 호출한 메서드로 전달한다.
이 값의 타입은 반환타입과 일치하거나 적어도 자동 형 변환이 가능해야 한다.
출력값은 최대 하나만 허용한다.

### 지역변수

메서드 내에 선언된 변수들은 그 메서드 내에서만 사용할 수 있으므로 서로 다른 메서드라면 같은 이름의 변수를 선언해도 된다.

## 메서드의 호출

메서드를 정의했어도 호출되지 않으면 아무 일도 일어나지 않는다.
메서드 호출 방법은 다음과 같다.

메서드이름 (값1, 값2..); // 메서드 호출 방법

printA();               // void printA(void)를 호출
int result = add (3,5); // int add(int x, int y)를 호출하고 결과를 result에 저장

### 인자와 매개변수 ★

메서드를 호출할 때 괄호() 안에 지정해준 값들을 "인자(argument)" 또는 "인수" 라고 한다.
인자의 개수와 순서는 호출된 메서드에 선언된 매개변수와 일치해야 한다.
인자의 타입은 매개변수의 타입과 일치하거나 자동변환이 가능해야 한다.

### 메서드의 실행 흐름 ★★★★★

같은 클래스 내의 메서드끼리는 참조변수를 사용하지 않고 호출이 가능하지만 static 메서드는 같은 클래스 내의 인스턴스 메서드를 호출 할 수 없다.

class MyMath {
  long add(long a, long b) {
    long result = a + b;
    return result;
      return a + b;
  }
  
MyMath mm = new MyMath(); // 인스턴스 생성

long value = mm.add(1L, 2L);

long add(long a, long b) {
  long result = a + b;
  return result;
  }
  
실행순서

1. main 메서드에서 메서드 add를 호출한다. 호출시 지정한 1L과 2L이 메서드 add 매개변수 a,b에 각각 대입된다.
2. 메서드 add의 괄호 {} 안에 있는 문장을 순서대로 수행한다.
3. 메서드 add의 모든 문장이 실행되거나 return 문을 만나면 , 호출한 메서드(main 메서드)로 되돌아와서 이후의 문장들을 실행한다.
 
## return문

현재 실행중인 메서드를 종료하고 호출한 메서드로 되돌아간다.


### 반환값

주로 변수가 오지만 항상 그런 것은 아니다.

int add(int x, int y) {                     int add(int x, int y) {
  int result = x + y;           -->           return x + y;
  return result;                              }
  } 

## 매개변수의 유효성 검사

메서드의 구현부 {} 를 작성할 때 제일 먼저 해야 하는 일이 매개변수의 값이 적절한 것인지 확인 하는 것이다.

## Jvm 메모리 구조 p.261















